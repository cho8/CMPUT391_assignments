// Avery Tan
// Christina Ho
// Assignment2 CMPUT391

/*
Q5 (15 pts)

The goal of this question is to quantify the impact (if any) of the built-in
R-Tree module in SQLite. To do so, build standard SQlite indexes on each of the
individual Cartesian coordinates of the POIs.

Write a C program, in a file called q5.c that:

Generates 100 randomly chosen bounding squares with side of length l, read as a
parameter to the program. The coordinates of the square should be generated by
your program.
Computes the average time (out of 20 runs for each query rectangle) to find the
total number of objects in that square, using the R-Tree and using the standard
SQLite indexes (only).
Prints the average times for each scenario after all runs.
The output of the program should look like this:

Parameter l: ...

Average runtime with r-tree: ... ms

Average runtime without r-tree: ... ms
*/

#include <stdio.h>
#include <sqlite3.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>


void randCoord(int* arry, int newSeed) {
  srand(newSeed);
  for (int i=0; i<100; i++) {
    arry[i] = rand() % 1000+1;
  }
}

int print_result(void *a_param, int argc, char **argv, char **column) {
  for (int i=0; i< argc; i++)
        printf("%s \t", argv[i]);
    printf("\n");
    return 0;
}

int main(int argc, char **argv){


  sqlite3 *db; //the database
  char database_name[]= "as2.db";

  if( argc!=2 ){
    	fprintf(stderr, "Usage: %s <length> \n", argv[0]);
    	return(1);
  }

  int rc;

  rc = sqlite3_open(database_name, &db);
  if( rc ){
    fprintf(stderr, "Can't open database: %s\n", sqlite3_errmsg(db));
    sqlite3_close(db);
    return(1);
  }

  int l = atoi(argv[1]);

  // array of randomly generated coordinates
  int xarry[100];
  int yarry[100];

  randCoord(xarry,4);
  randCoord(yarry,128);

  double rtree_times[100]={0};
  double index_times[100]={0};

  // run each query rectangle 20 times for rtree and standard indexes
  for (int j=0; j<20; j++) {
      // 100 bounding squares
      for (int i=0; i<100; i++) {

      //rtree execution
      char *sql = sqlite3_mprintf( "SELECT id "\
                                  "FROM poi_rtree "\
                                  "WHERE minX>=%d "\
                                  "AND maxX<=%d "\
                                  "AND minY>=%d "\
                                  "AND maxY<=%d;",
                                  xarry[i], xarry[i]+l, yarry[i], yarry[i]+l);

      //time the rtree execution
      clock_t rtree_begin = clock();
      //rc = sqlite3_exec(db,sql,print_result,0,0); //print the result
      rc = sqlite3_exec(db,sql,0,0,0);
      clock_t rtree_end = clock();

      // add current execution time to total
      rtree_times[i] += (double)(rtree_end-rtree_begin);

      // printf("%f\n", times[i]);
      sqlite3_free(sql);


      // standard index execution
      char *sql_index = sqlite3_mprintf( "SELECT id "\
                                  "FROM poi "\
                                  "WHERE x1>=%d "\
                                  "AND x2<=%d "\
                                  "AND y1>=%d "\
                                  "AND y2<=%d;",
                                  xarry[i], xarry[i]+l, yarry[i], yarry[i]+l);

      clock_t index_begin = clock();
      //rc = sqlite3_exec(db,sql,print_result,0,0); //print the result
      rc = sqlite3_exec(db,sql_index,0,0,0);
      clock_t index_end = clock();

      // add current execution time to total
      index_times[i] += (double)(index_end-index_begin);
      sqlite3_free(sql_index);

    }
    // average total execution times
    rtree_times[j] = rtree_times[j]/100;
    // average total execution times
    index_times[j] = index_times[j]/100;

  }
  double tot_rtree=0;
  double tot_index=0;
  // sum the times
  for (int i=0; i<20;i++){
      tot_rtree += rtree_times[i];
      tot_index += index_times[i];
  }

  // print param and averages
  printf("Parameter l: %s\n", argv[1]);
  printf("Average runtime with rtree: %f ms\n", (tot_rtree/20)*1000/(CLOCKS_PER_SEC) );
  printf("Average runtime without rtree: %f ms\n", (tot_index/20)*1000/(CLOCKS_PER_SEC) );

}
